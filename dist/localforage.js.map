{"version":3,"sources":["localforage.js"],"names":["f","exports","_typeof2","module","define","amd","window","global","self","this","localforage","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","scheduleDrain","observer","Mutation","MutationObserver","WebKitMutationObserver","called","g","nextTick","document","createTextNode","observe","element","data","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","setTimeout","channel","port1","onmessage","port2","postMessage","characterData","oldQueue","len","queue","draining","task","2","INTERNAL","handlers","REJECTED","FULFILLED","resolver","QueueItem","PENDING","onFulfilled","onRejected","promise","Promise","callFulfilled","TypeError","callRejected","unwrap","state","immediate","returnValue","func","reject","resolve","getThen","obj","then","tryCatch","result","apply","arguments","safelyResolveThenable","value","onSuccess","thenable","onError","status","out","prototype","constructor","outcome","push","otherCallFulfilled","otherCallRejected","error","reason","tryToUnwrap","all","iterable","allResolver","outValue","values","resolved","race","Object","toString","response","3","4","_typeof","Symbol","iterator","idb","indexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","getIDB","createBlob","parts","properties","Blob","name","builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","append","getBlob","type","Promise$1","executeCallback","IDBKeyRange","callback","executeTwoCallbacks","errorCallback","normalizeKey","key","Builder","console","warn","String","getCallback","DETECT_BLOB_SUPPORT_STORE","supportsBlobs","dbContexts","READ_WRITE","_checkBlobSupport","txn","put","blob","onabort","preventDefault","stopPropagation","oncomplete","matchedChrome","_binStringToArrayBuffer","bin","match","userAgent","matchedEdge","parseInt","_deferReadiness","dbInfo","dbContext","deferredOperation","_checkBlobSupportWithoutCaching","transaction","objectStore","deferredOperations","dbReady","_advanceReadiness","pop","_rejectReadiness","err","db","upgradeNeeded","close","dbArgs","openreq","open","onupgradeneeded","createObjectStore","storeName","ex","oldVersion","newVersion","onerror","_getConnection","onsuccess","_getOriginalConnection","_isUpgradeNeeded","defaultVersion","isDowngrade","version","isUpgrade","isNewStore","incVersion","_decodeBlob","encodedBlob","buf","ArrayBuffer","arr","charCodeAt","atob","_isEncodedBlob","__local_forage_encoded_blob","_fullyReady","_initReady","_dbInfo","reader","FileReader","createTransaction","mode","retries","undefined","tx","forages","forage","objectStoreNames","contains","_getUpgradedConnection","readAsBinaryString","arrayBuff","asyncStorage","_driver","_initStorage","options","ready","j","initPromises","ignoreErrors","slice","k","req","isSafari","test","navigator","platform","hasFetch","fetch","indexOf","webkitIndexedDB","iterate","READ_ONLY","store","iterationNumber","cursor","blobSupport","onloadend","base64","btoa","target","removeItem","clear","advanced","advance","keys","dropInstance","currentConfig","dbPromise","deleteDatabase","dropDBPromise","deleteObjectStore","_forage2","config","BLOB_TYPE_PREFIX","SERIALIZED_MARKER","SERIALIZED_MARKER_LENGTH","TYPE_ARRAYBUFFER","TYPE_BLOB","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT32ARRAY","TYPE_UINT16ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","setItem","serializedString","bufferLength","openDatabase","buffer","bytes","BASE_CHARS","encoded1","BLOB_TYPE_PREFIX_REGEX","encoded2","encoded3","encoded4","bufferToString","TYPE_SERIALIZED_MARKER_LENGTH","base64String","stringToBuffer","localforageSerializer","serialize","valueType","toString$1","marker","Uint8Array","TYPE_FLOAT64ARRAY","fileReader","str","deserialize","JSON","parse","blobType","substring","matcher","readAsArrayBuffer","Int8Array","Uint8ClampedArray","TYPE_INT16ARRAY","Int16Array","Int32Array","Float32Array","Float64Array","createDbTable","executeSql","tryExecuteSql","sqlStatement","args","SYNTAX_ERR","results","_initStorage$1","webSQLStorage","dbInfoPromise","description","size","serializer","storeNames","rows","getItem$1","item","iterate$1","getItem","originalValue","retriesLeft","sqlError","QUOTA_ERR","operationInfo","_setItem","removeItem$1","c","clear$1","length$1","key$1","getAllStoreNames","keys$1","dropTable","operations","keyPrefix","defaultConfig","localStorage","localStorageTestKey","_support","checkIfLocalStorageThrows","_defaultConfig","_isLocalStorageUsable","isLocalStorageValid","keyPrefixLength","iterate$2","_getKeyPrefix","removeItem$2","keys$2","itemKey","key$2","searchElement","x","y","array","isNaN","isArray","Array","arg","DefinedDrivers","DriverSupport","localStorageWrapper","clear$2","DefaultDrivers","INDEXEDDB","WEBSQL","LOCALSTORAGE","dropInstance$2","DefaultConfig","sameValue","driver","DefaultDriverOrder","callWhenReady","localForageInstance","libraryMethod","_args","extend","_key","LocalForage","driverTypeKey","instance","Constructor","hasOwnProperty","driverName","_config","_driverSet","_initDriver","_ready","_wrapLibraryMethodsWithReady","setDriver","replace","defineDriver","driverObject","complianceError","driverMethods","LibraryMethods","concat","driverMethodName","includes","methodNotImplementedFactory","methodName","_i","_len","OptionalDriverMethods","optionalDriverMethod","configureMissingMethods","setDriverSupport","support","isRequired","getDriver","getDriverPromise","getSerializer","info","serializerPromise","drivers","supportedDrivers","_getSupportedDrivers","setDriverToConfig","extendSelfWithDriver","_extend","oldDriverSetDone","currentDriverIndex","driverPromiseLoop","supports","libraryMethodsAndProperties","createInstance","localforage_js"],"mappings":"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","file":"localforage.js","sourcesContent":["/*!\r\n    localForage -- Offline Storage, Improved\r\n    Version 1.6.0\r\n    https://localforage.github.io/localForage\r\n    (c) 2013-2017 Mozilla, Apache License 2.0\r\n*/\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.localforage = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\r\n    (function (global){\r\n    'use strict';\r\n    var Mutation = global.MutationObserver || global.WebKitMutationObserver;\r\n    \r\n    var scheduleDrain;\r\n    \r\n    {\r\n      if (Mutation) {\r\n        var called = 0;\r\n        var observer = new Mutation(nextTick);\r\n        var element = global.document.createTextNode('');\r\n        observer.observe(element, {\r\n          characterData: true\r\n        });\r\n        scheduleDrain = function () {\r\n          element.data = (called = ++called % 2);\r\n        };\r\n      } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\r\n        var channel = new global.MessageChannel();\r\n        channel.port1.onmessage = nextTick;\r\n        scheduleDrain = function () {\r\n          channel.port2.postMessage(0);\r\n        };\r\n      } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\r\n        scheduleDrain = function () {\r\n    \r\n          // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\r\n          // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\r\n          var scriptEl = global.document.createElement('script');\r\n          scriptEl.onreadystatechange = function () {\r\n            nextTick();\r\n    \r\n            scriptEl.onreadystatechange = null;\r\n            scriptEl.parentNode.removeChild(scriptEl);\r\n            scriptEl = null;\r\n          };\r\n          global.document.documentElement.appendChild(scriptEl);\r\n        };\r\n      } else {\r\n        scheduleDrain = function () {\r\n          setTimeout(nextTick, 0);\r\n        };\r\n      }\r\n    }\r\n    \r\n    var draining;\r\n    var queue = [];\r\n    //named nextTick for less confusing stack traces\r\n    function nextTick() {\r\n      draining = true;\r\n      var i, oldQueue;\r\n      var len = queue.length;\r\n      while (len) {\r\n        oldQueue = queue;\r\n        queue = [];\r\n        i = -1;\r\n        while (++i < len) {\r\n          oldQueue[i]();\r\n        }\r\n        len = queue.length;\r\n      }\r\n      draining = false;\r\n    }\r\n    \r\n    module.exports = immediate;\r\n    function immediate(task) {\r\n      if (queue.push(task) === 1 && !draining) {\r\n        scheduleDrain();\r\n      }\r\n    }\r\n    \r\n    }).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    },{}],2:[function(_dereq_,module,exports){\r\n    'use strict';\r\n    var immediate = _dereq_(1);\r\n    \r\n    /* istanbul ignore next */\r\n    function INTERNAL() {}\r\n    \r\n    var handlers = {};\r\n    \r\n    var REJECTED = ['REJECTED'];\r\n    var FULFILLED = ['FULFILLED'];\r\n    var PENDING = ['PENDING'];\r\n    \r\n    module.exports = Promise;\r\n    \r\n    function Promise(resolver) {\r\n      if (typeof resolver !== 'function') {\r\n        throw new TypeError('resolver must be a function');\r\n      }\r\n      this.state = PENDING;\r\n      this.queue = [];\r\n      this.outcome = void 0;\r\n      if (resolver !== INTERNAL) {\r\n        safelyResolveThenable(this, resolver);\r\n      }\r\n    }\r\n    \r\n    Promise.prototype[\"catch\"] = function (onRejected) {\r\n      return this.then(null, onRejected);\r\n    };\r\n    Promise.prototype.then = function (onFulfilled, onRejected) {\r\n      if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\r\n        typeof onRejected !== 'function' && this.state === REJECTED) {\r\n        return this;\r\n      }\r\n      var promise = new this.constructor(INTERNAL);\r\n      if (this.state !== PENDING) {\r\n        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\r\n        unwrap(promise, resolver, this.outcome);\r\n      } else {\r\n        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\r\n      }\r\n    \r\n      return promise;\r\n    };\r\n    function QueueItem(promise, onFulfilled, onRejected) {\r\n      this.promise = promise;\r\n      if (typeof onFulfilled === 'function') {\r\n        this.onFulfilled = onFulfilled;\r\n        this.callFulfilled = this.otherCallFulfilled;\r\n      }\r\n      if (typeof onRejected === 'function') {\r\n        this.onRejected = onRejected;\r\n        this.callRejected = this.otherCallRejected;\r\n      }\r\n    }\r\n    QueueItem.prototype.callFulfilled = function (value) {\r\n      handlers.resolve(this.promise, value);\r\n    };\r\n    QueueItem.prototype.otherCallFulfilled = function (value) {\r\n      unwrap(this.promise, this.onFulfilled, value);\r\n    };\r\n    QueueItem.prototype.callRejected = function (value) {\r\n      handlers.reject(this.promise, value);\r\n    };\r\n    QueueItem.prototype.otherCallRejected = function (value) {\r\n      unwrap(this.promise, this.onRejected, value);\r\n    };\r\n    \r\n    function unwrap(promise, func, value) {\r\n      immediate(function () {\r\n        var returnValue;\r\n        try {\r\n          returnValue = func(value);\r\n        } catch (e) {\r\n          return handlers.reject(promise, e);\r\n        }\r\n        if (returnValue === promise) {\r\n          handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\r\n        } else {\r\n          handlers.resolve(promise, returnValue);\r\n        }\r\n      });\r\n    }\r\n    \r\n    handlers.resolve = function (self, value) {\r\n      var result = tryCatch(getThen, value);\r\n      if (result.status === 'error') {\r\n        return handlers.reject(self, result.value);\r\n      }\r\n      var thenable = result.value;\r\n    \r\n      if (thenable) {\r\n        safelyResolveThenable(self, thenable);\r\n      } else {\r\n        self.state = FULFILLED;\r\n        self.outcome = value;\r\n        var i = -1;\r\n        var len = self.queue.length;\r\n        while (++i < len) {\r\n          self.queue[i].callFulfilled(value);\r\n        }\r\n      }\r\n      return self;\r\n    };\r\n    handlers.reject = function (self, error) {\r\n      self.state = REJECTED;\r\n      self.outcome = error;\r\n      var i = -1;\r\n      var len = self.queue.length;\r\n      while (++i < len) {\r\n        self.queue[i].callRejected(error);\r\n      }\r\n      return self;\r\n    };\r\n    \r\n    function getThen(obj) {\r\n      // Make sure we only access the accessor once as required by the spec\r\n      var then = obj && obj.then;\r\n      if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\r\n        return function appyThen() {\r\n          then.apply(obj, arguments);\r\n        };\r\n      }\r\n    }\r\n    \r\n    function safelyResolveThenable(self, thenable) {\r\n      // Either fulfill, reject or reject with error\r\n      var called = false;\r\n      function onError(value) {\r\n        if (called) {\r\n          return;\r\n        }\r\n        called = true;\r\n        handlers.reject(self, value);\r\n      }\r\n    \r\n      function onSuccess(value) {\r\n        if (called) {\r\n          return;\r\n        }\r\n        called = true;\r\n        handlers.resolve(self, value);\r\n      }\r\n    \r\n      function tryToUnwrap() {\r\n        thenable(onSuccess, onError);\r\n      }\r\n    \r\n      var result = tryCatch(tryToUnwrap);\r\n      if (result.status === 'error') {\r\n        onError(result.value);\r\n      }\r\n    }\r\n    \r\n    function tryCatch(func, value) {\r\n      var out = {};\r\n      try {\r\n        out.value = func(value);\r\n        out.status = 'success';\r\n      } catch (e) {\r\n        out.status = 'error';\r\n        out.value = e;\r\n      }\r\n      return out;\r\n    }\r\n    \r\n    Promise.resolve = resolve;\r\n    function resolve(value) {\r\n      if (value instanceof this) {\r\n        return value;\r\n      }\r\n      return handlers.resolve(new this(INTERNAL), value);\r\n    }\r\n    \r\n    Promise.reject = reject;\r\n    function reject(reason) {\r\n      var promise = new this(INTERNAL);\r\n      return handlers.reject(promise, reason);\r\n    }\r\n    \r\n    Promise.all = all;\r\n    function all(iterable) {\r\n      var self = this;\r\n      if (Object.prototype.toString.call(iterable) !== '[object Array]') {\r\n        return this.reject(new TypeError('must be an array'));\r\n      }\r\n    \r\n      var len = iterable.length;\r\n      var called = false;\r\n      if (!len) {\r\n        return this.resolve([]);\r\n      }\r\n    \r\n      var values = new Array(len);\r\n      var resolved = 0;\r\n      var i = -1;\r\n      var promise = new this(INTERNAL);\r\n    \r\n      while (++i < len) {\r\n        allResolver(iterable[i], i);\r\n      }\r\n      return promise;\r\n      function allResolver(value, i) {\r\n        self.resolve(value).then(resolveFromAll, function (error) {\r\n          if (!called) {\r\n            called = true;\r\n            handlers.reject(promise, error);\r\n          }\r\n        });\r\n        function resolveFromAll(outValue) {\r\n          values[i] = outValue;\r\n          if (++resolved === len && !called) {\r\n            called = true;\r\n            handlers.resolve(promise, values);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    Promise.race = race;\r\n    function race(iterable) {\r\n      var self = this;\r\n      if (Object.prototype.toString.call(iterable) !== '[object Array]') {\r\n        return this.reject(new TypeError('must be an array'));\r\n      }\r\n    \r\n      var len = iterable.length;\r\n      var called = false;\r\n      if (!len) {\r\n        return this.resolve([]);\r\n      }\r\n    \r\n      var i = -1;\r\n      var promise = new this(INTERNAL);\r\n    \r\n      while (++i < len) {\r\n        resolver(iterable[i]);\r\n      }\r\n      return promise;\r\n      function resolver(value) {\r\n        self.resolve(value).then(function (response) {\r\n          if (!called) {\r\n            called = true;\r\n            handlers.resolve(promise, response);\r\n          }\r\n        }, function (error) {\r\n          if (!called) {\r\n            called = true;\r\n            handlers.reject(promise, error);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    \r\n    },{\"1\":1}],3:[function(_dereq_,module,exports){\r\n    (function (global){\r\n    'use strict';\r\n    if (typeof global.Promise !== 'function') {\r\n      global.Promise = _dereq_(2);\r\n    }\r\n    \r\n    }).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\r\n    },{\"2\":2}],4:[function(_dereq_,module,exports){\r\n    'use strict';\r\n    \r\n    var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n    \r\n    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\r\n    \r\n    function getIDB() {\r\n        /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\r\n        try {\r\n            if (typeof indexedDB !== 'undefined') {\r\n                return indexedDB;\r\n            }\r\n            if (typeof webkitIndexedDB !== 'undefined') {\r\n                return webkitIndexedDB;\r\n            }\r\n            if (typeof mozIndexedDB !== 'undefined') {\r\n                return mozIndexedDB;\r\n            }\r\n            if (typeof OIndexedDB !== 'undefined') {\r\n                return OIndexedDB;\r\n            }\r\n            if (typeof msIndexedDB !== 'undefined') {\r\n                return msIndexedDB;\r\n            }\r\n        } catch (e) {\r\n            return;\r\n        }\r\n    }\r\n    \r\n    var idb = getIDB();\r\n    \r\n    function isIndexedDBValid() {\r\n        try {\r\n            // Initialize IndexedDB; fall back to vendor-prefixed versions\r\n            // if needed.\r\n            if (!idb) {\r\n                return false;\r\n            }\r\n            // We mimic PouchDB here;\r\n            //\r\n            // We test for openDatabase because IE Mobile identifies itself\r\n            // as Safari. Oh the lulz...\r\n            var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\r\n    \r\n            var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\r\n    \r\n            // Safari <10.1 does not meet our requirements for IDB support (#5572)\r\n            // since Safari 10.1 shipped with fetch, we can use that to detect it\r\n            return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\r\n            // some outdated implementations of IDB that appear on Samsung\r\n            // and HTC Android devices <4.4 are missing IDBKeyRange\r\n            // See: https://github.com/mozilla/localForage/issues/128\r\n            // See: https://github.com/mozilla/localForage/issues/272\r\n            typeof IDBKeyRange !== 'undefined';\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    // Abstracts constructing a Blob object, so it also works in older\r\n    // browsers that don't support the native Blob constructor. (i.e.\r\n    // old QtWebKit versions, at least).\r\n    // Abstracts constructing a Blob object, so it also works in older\r\n    // browsers that don't support the native Blob constructor. (i.e.\r\n    // old QtWebKit versions, at least).\r\n    function createBlob(parts, properties) {\r\n        /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\r\n        parts = parts || [];\r\n        properties = properties || {};\r\n        try {\r\n            return new Blob(parts, properties);\r\n        } catch (e) {\r\n            if (e.name !== 'TypeError') {\r\n                throw e;\r\n            }\r\n            var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\r\n            var builder = new Builder();\r\n            for (var i = 0; i < parts.length; i += 1) {\r\n                builder.append(parts[i]);\r\n            }\r\n            return builder.getBlob(properties.type);\r\n        }\r\n    }\r\n    \r\n    // This is CommonJS because lie is an external dependency, so Rollup\r\n    // can just ignore it.\r\n    if (typeof Promise === 'undefined') {\r\n        // In the \"nopromises\" build this will just throw if you don't have\r\n        // a global promise object, but it would throw anyway later.\r\n        _dereq_(3);\r\n    }\r\n    var Promise$1 = Promise;\r\n    \r\n    function executeCallback(promise, callback) {\r\n        if (callback) {\r\n            promise.then(function (result) {\r\n                callback(null, result);\r\n            }, function (error) {\r\n                callback(error);\r\n            });\r\n        }\r\n    }\r\n    \r\n    function executeTwoCallbacks(promise, callback, errorCallback) {\r\n        if (typeof callback === 'function') {\r\n            promise.then(callback);\r\n        }\r\n    \r\n        if (typeof errorCallback === 'function') {\r\n            promise[\"catch\"](errorCallback);\r\n        }\r\n    }\r\n    \r\n    function normalizeKey(key) {\r\n        // Cast the key to a string, as that's all we can set as a key.\r\n        if (typeof key !== 'string') {\r\n            console.warn(key + ' used as a key, but it is not a string.');\r\n            key = String(key);\r\n        }\r\n    \r\n        return key;\r\n    }\r\n    \r\n    function getCallback() {\r\n        if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\r\n            return arguments[arguments.length - 1];\r\n        }\r\n    }\r\n    \r\n    // Some code originally from async_storage.js in\r\n    // [Gaia](https://github.com/mozilla-b2g/gaia).\r\n    \r\n    var DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\r\n    var supportsBlobs = void 0;\r\n    var dbContexts = {};\r\n    var toString = Object.prototype.toString;\r\n    \r\n    // Transaction Modes\r\n    var READ_ONLY = 'readonly';\r\n    var READ_WRITE = 'readwrite';\r\n    \r\n    // Transform a binary string to an array buffer, because otherwise\r\n    // weird stuff happens when you try to work with the binary string directly.\r\n    // It is known.\r\n    // From http://stackoverflow.com/questions/14967647/ (continues on next line)\r\n    // encode-decode-image-with-base64-breaks-image (2013-04-21)\r\n    function _binStringToArrayBuffer(bin) {\r\n        var length = bin.length;\r\n        var buf = new ArrayBuffer(length);\r\n        var arr = new Uint8Array(buf);\r\n        for (var i = 0; i < length; i++) {\r\n            arr[i] = bin.charCodeAt(i);\r\n        }\r\n        return buf;\r\n    }\r\n    \r\n    //\r\n    // Blobs are not supported in all versions of IndexedDB, notably\r\n    // Chrome <37 and Android <5. In those versions, storing a blob will throw.\r\n    //\r\n    // Various other blob bugs exist in Chrome v37-42 (inclusive).\r\n    // Detecting them is expensive and confusing to users, and Chrome 37-42\r\n    // is at very low usage worldwide, so we do a hacky userAgent check instead.\r\n    //\r\n    // content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\r\n    // 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\r\n    // FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\r\n    //\r\n    // Code borrowed from PouchDB. See:\r\n    // https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\r\n    //\r\n    function _checkBlobSupportWithoutCaching(idb) {\r\n        return new Promise$1(function (resolve) {\r\n            var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\r\n            var blob = createBlob(['']);\r\n            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\r\n    \r\n            txn.onabort = function (e) {\r\n                // If the transaction aborts now its due to not being able to\r\n                // write to the database, likely due to the disk being full\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                resolve(false);\r\n            };\r\n    \r\n            txn.oncomplete = function () {\r\n                var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\r\n                var matchedEdge = navigator.userAgent.match(/Edge\\//);\r\n                // MS Edge pretends to be Chrome 42:\r\n                // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\r\n                resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\r\n            };\r\n        })[\"catch\"](function () {\r\n            return false; // error, so assume unsupported\r\n        });\r\n    }\r\n    \r\n    function _checkBlobSupport(idb) {\r\n        if (typeof supportsBlobs === 'boolean') {\r\n            return Promise$1.resolve(supportsBlobs);\r\n        }\r\n        return _checkBlobSupportWithoutCaching(idb).then(function (value) {\r\n            supportsBlobs = value;\r\n            return supportsBlobs;\r\n        });\r\n    }\r\n    \r\n    function _deferReadiness(dbInfo) {\r\n        var dbContext = dbContexts[dbInfo.name];\r\n    \r\n        // Create a deferred object representing the current database operation.\r\n        var deferredOperation = {};\r\n    \r\n        deferredOperation.promise = new Promise$1(function (resolve, reject) {\r\n            deferredOperation.resolve = resolve;\r\n            deferredOperation.reject = reject;\r\n        });\r\n    \r\n        // Enqueue the deferred operation.\r\n        dbContext.deferredOperations.push(deferredOperation);\r\n    \r\n        // Chain its promise to the database readiness.\r\n        if (!dbContext.dbReady) {\r\n            dbContext.dbReady = deferredOperation.promise;\r\n        } else {\r\n            dbContext.dbReady = dbContext.dbReady.then(function () {\r\n                return deferredOperation.promise;\r\n            });\r\n        }\r\n    }\r\n    \r\n    function _advanceReadiness(dbInfo) {\r\n        var dbContext = dbContexts[dbInfo.name];\r\n    \r\n        // Dequeue a deferred operation.\r\n        var deferredOperation = dbContext.deferredOperations.pop();\r\n    \r\n        // Resolve its promise (which is part of the database readiness\r\n        // chain of promises).\r\n        if (deferredOperation) {\r\n            deferredOperation.resolve();\r\n            return deferredOperation.promise;\r\n        }\r\n    }\r\n    \r\n    function _rejectReadiness(dbInfo, err) {\r\n        var dbContext = dbContexts[dbInfo.name];\r\n    \r\n        // Dequeue a deferred operation.\r\n        var deferredOperation = dbContext.deferredOperations.pop();\r\n    \r\n        // Reject its promise (which is part of the database readiness\r\n        // chain of promises).\r\n        if (deferredOperation) {\r\n            deferredOperation.reject(err);\r\n            return deferredOperation.promise;\r\n        }\r\n    }\r\n    \r\n    function _getConnection(dbInfo, upgradeNeeded) {\r\n        return new Promise$1(function (resolve, reject) {\r\n            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\r\n    \r\n            if (dbInfo.db) {\r\n                if (upgradeNeeded) {\r\n                    _deferReadiness(dbInfo);\r\n                    dbInfo.db.close();\r\n                } else {\r\n                    return resolve(dbInfo.db);\r\n                }\r\n            }\r\n    \r\n            var dbArgs = [dbInfo.name];\r\n    \r\n            if (upgradeNeeded) {\r\n                dbArgs.push(dbInfo.version);\r\n            }\r\n    \r\n            var openreq = idb.open.apply(idb, dbArgs);\r\n    \r\n            if (upgradeNeeded) {\r\n                openreq.onupgradeneeded = function (e) {\r\n                    var db = openreq.result;\r\n                    try {\r\n                        db.createObjectStore(dbInfo.storeName);\r\n                        if (e.oldVersion <= 1) {\r\n                            // Added when support for blob shims was added\r\n                            db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\r\n                        }\r\n                    } catch (ex) {\r\n                        if (ex.name === 'ConstraintError') {\r\n                            console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\r\n                        } else {\r\n                            throw ex;\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n    \r\n            openreq.onerror = function (e) {\r\n                e.preventDefault();\r\n                reject(openreq.error);\r\n            };\r\n    \r\n            openreq.onsuccess = function () {\r\n                resolve(openreq.result);\r\n                _advanceReadiness(dbInfo);\r\n            };\r\n        });\r\n    }\r\n    \r\n    function _getOriginalConnection(dbInfo) {\r\n        return _getConnection(dbInfo, false);\r\n    }\r\n    \r\n    function _getUpgradedConnection(dbInfo) {\r\n        return _getConnection(dbInfo, true);\r\n    }\r\n    \r\n    function _isUpgradeNeeded(dbInfo, defaultVersion) {\r\n        if (!dbInfo.db) {\r\n            return true;\r\n        }\r\n    \r\n        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\r\n        var isDowngrade = dbInfo.version < dbInfo.db.version;\r\n        var isUpgrade = dbInfo.version > dbInfo.db.version;\r\n    \r\n        if (isDowngrade) {\r\n            // If the version is not the default one\r\n            // then warn for impossible downgrade.\r\n            if (dbInfo.version !== defaultVersion) {\r\n                console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\r\n            }\r\n            // Align the versions to prevent errors.\r\n            dbInfo.version = dbInfo.db.version;\r\n        }\r\n    \r\n        if (isUpgrade || isNewStore) {\r\n            // If the store is new then increment the version (if needed).\r\n            // This will trigger an \"upgradeneeded\" event which is required\r\n            // for creating a store.\r\n            if (isNewStore) {\r\n                var incVersion = dbInfo.db.version + 1;\r\n                if (incVersion > dbInfo.version) {\r\n                    dbInfo.version = incVersion;\r\n                }\r\n            }\r\n    \r\n            return true;\r\n        }\r\n    \r\n        return false;\r\n    }\r\n    \r\n    // encode a blob for indexeddb engines that don't support blobs\r\n    function _encodeBlob(blob) {\r\n        return new Promise$1(function (resolve, reject) {\r\n            var reader = new FileReader();\r\n            reader.onerror = reject;\r\n            reader.onloadend = function (e) {\r\n                var base64 = btoa(e.target.result || '');\r\n                resolve({\r\n                    __local_forage_encoded_blob: true,\r\n                    data: base64,\r\n                    type: blob.type\r\n                });\r\n            };\r\n            reader.readAsBinaryString(blob);\r\n        });\r\n    }\r\n    \r\n    // decode an encoded blob\r\n    function _decodeBlob(encodedBlob) {\r\n        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\r\n        return createBlob([arrayBuff], { type: encodedBlob.type });\r\n    }\r\n    \r\n    // is this one of our fancy encoded blobs?\r\n    function _isEncodedBlob(value) {\r\n        return value && value.__local_forage_encoded_blob;\r\n    }\r\n    \r\n    // Specialize the default `ready()` function by making it dependent\r\n    // on the current database operations. Thus, the driver will be actually\r\n    // ready when it's been initialized (default) *and* there are no pending\r\n    // operations on the database (initiated by some other instances).\r\n    function _fullyReady(callback) {\r\n        var self = this;\r\n    \r\n        var promise = self._initReady().then(function () {\r\n            var dbContext = dbContexts[self._dbInfo.name];\r\n    \r\n            if (dbContext && dbContext.dbReady) {\r\n                return dbContext.dbReady;\r\n            }\r\n        });\r\n    \r\n        executeTwoCallbacks(promise, callback, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Try to establish a new db connection to replace the\r\n    // current one which is broken (i.e. experiencing\r\n    // InvalidStateError while creating a transaction).\r\n    function _tryReconnect(dbInfo) {\r\n        _deferReadiness(dbInfo);\r\n    \r\n        var dbContext = dbContexts[dbInfo.name];\r\n        var forages = dbContext.forages;\r\n    \r\n        for (var i = 0; i < forages.length; i++) {\r\n            var forage = forages[i];\r\n            if (forage._dbInfo.db) {\r\n                forage._dbInfo.db.close();\r\n                forage._dbInfo.db = null;\r\n            }\r\n        }\r\n        dbInfo.db = null;\r\n    \r\n        return _getOriginalConnection(dbInfo).then(function (db) {\r\n            dbInfo.db = db;\r\n            if (_isUpgradeNeeded(dbInfo)) {\r\n                // Reopen the database for upgrading.\r\n                return _getUpgradedConnection(dbInfo);\r\n            }\r\n            return db;\r\n        }).then(function (db) {\r\n            // store the latest db reference\r\n            // in case the db was upgraded\r\n            dbInfo.db = dbContext.db = db;\r\n            for (var i = 0; i < forages.length; i++) {\r\n                forages[i]._dbInfo.db = db;\r\n            }\r\n        })[\"catch\"](function (err) {\r\n            _rejectReadiness(dbInfo, err);\r\n            throw err;\r\n        });\r\n    }\r\n    \r\n    // FF doesn't like Promises (micro-tasks) and IDDB store operations,\r\n    // so we have to do it with callbacks\r\n    function createTransaction(dbInfo, mode, callback, retries) {\r\n        if (retries === undefined) {\r\n            retries = 1;\r\n        }\r\n    \r\n        try {\r\n            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\r\n            callback(null, tx);\r\n        } catch (err) {\r\n            if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\r\n                return Promise$1.resolve().then(function () {\r\n                    if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\r\n                        // increase the db version, to create the new ObjectStore\r\n                        if (dbInfo.db) {\r\n                            dbInfo.version = dbInfo.db.version + 1;\r\n                        }\r\n                        // Reopen the database for upgrading.\r\n                        return _getUpgradedConnection(dbInfo);\r\n                    }\r\n                }).then(function () {\r\n                    return _tryReconnect(dbInfo).then(function () {\r\n                        createTransaction(dbInfo, mode, callback, retries - 1);\r\n                    });\r\n                })[\"catch\"](callback);\r\n            }\r\n    \r\n            callback(err);\r\n        }\r\n    }\r\n    \r\n    function createDbContext() {\r\n        return {\r\n            // Running localForages sharing a database.\r\n            forages: [],\r\n            // Shared database.\r\n            db: null,\r\n            // Database readiness (promise).\r\n            dbReady: null,\r\n            // Deferred operations on the database.\r\n            deferredOperations: []\r\n        };\r\n    }\r\n    \r\n    // Open the IndexedDB database (automatically creates one if one didn't\r\n    // previously exist), using any options set in the config.\r\n    function _initStorage(options) {\r\n        var self = this;\r\n        var dbInfo = {\r\n            db: null\r\n        };\r\n    \r\n        if (options) {\r\n            for (var i in options) {\r\n                dbInfo[i] = options[i];\r\n            }\r\n        }\r\n    \r\n        // Get the current context of the database;\r\n        var dbContext = dbContexts[dbInfo.name];\r\n    \r\n        // ...or create a new context.\r\n        if (!dbContext) {\r\n            dbContext = createDbContext();\r\n            // Register the new context in the global container.\r\n            dbContexts[dbInfo.name] = dbContext;\r\n        }\r\n    \r\n        // Register itself as a running localForage in the current context.\r\n        dbContext.forages.push(self);\r\n    \r\n        // Replace the default `ready()` function with the specialized one.\r\n        if (!self._initReady) {\r\n            self._initReady = self.ready;\r\n            self.ready = _fullyReady;\r\n        }\r\n    \r\n        // Create an array of initialization states of the related localForages.\r\n        var initPromises = [];\r\n    \r\n        function ignoreErrors() {\r\n            // Don't handle errors here,\r\n            // just makes sure related localForages aren't pending.\r\n            return Promise$1.resolve();\r\n        }\r\n    \r\n        for (var j = 0; j < dbContext.forages.length; j++) {\r\n            var forage = dbContext.forages[j];\r\n            if (forage !== self) {\r\n                // Don't wait for itself...\r\n                initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\r\n            }\r\n        }\r\n    \r\n        // Take a snapshot of the related localForages.\r\n        var forages = dbContext.forages.slice(0);\r\n    \r\n        // Initialize the connection process only when\r\n        // all the related localForages aren't pending.\r\n        return Promise$1.all(initPromises).then(function () {\r\n            dbInfo.db = dbContext.db;\r\n            // Get the connection or open a new one without upgrade.\r\n            return _getOriginalConnection(dbInfo);\r\n        }).then(function (db) {\r\n            dbInfo.db = db;\r\n            if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\r\n                // Reopen the database for upgrading.\r\n                return _getUpgradedConnection(dbInfo);\r\n            }\r\n            return db;\r\n        }).then(function (db) {\r\n            dbInfo.db = dbContext.db = db;\r\n            self._dbInfo = dbInfo;\r\n            // Share the final connection amongst related localForages.\r\n            for (var k = 0; k < forages.length; k++) {\r\n                var forage = forages[k];\r\n                if (forage !== self) {\r\n                    // Self is already up-to-date.\r\n                    forage._dbInfo.db = dbInfo.db;\r\n                    forage._dbInfo.version = dbInfo.version;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    function getItem(key, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n                        var req = store.get(key);\r\n    \r\n                        req.onsuccess = function () {\r\n                            var value = req.result;\r\n                            if (value === undefined) {\r\n                                value = null;\r\n                            }\r\n                            if (_isEncodedBlob(value)) {\r\n                                value = _decodeBlob(value);\r\n                            }\r\n                            resolve(value);\r\n                        };\r\n    \r\n                        req.onerror = function () {\r\n                            reject(req.error);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Iterate over all items stored in database.\r\n    function iterate(iterator, callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n                        var req = store.openCursor();\r\n                        var iterationNumber = 1;\r\n    \r\n                        req.onsuccess = function () {\r\n                            var cursor = req.result;\r\n    \r\n                            if (cursor) {\r\n                                var value = cursor.value;\r\n                                if (_isEncodedBlob(value)) {\r\n                                    value = _decodeBlob(value);\r\n                                }\r\n                                var result = iterator(value, cursor.key, iterationNumber++);\r\n    \r\n                                // when the iterator callback retuns any\r\n                                // (non-`undefined`) value, then we stop\r\n                                // the iteration immediately\r\n                                if (result !== void 0) {\r\n                                    resolve(result);\r\n                                } else {\r\n                                    cursor[\"continue\"]();\r\n                                }\r\n                            } else {\r\n                                resolve();\r\n                            }\r\n                        };\r\n    \r\n                        req.onerror = function () {\r\n                            reject(req.error);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n    \r\n        return promise;\r\n    }\r\n    \r\n    function setItem(key, value, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            var dbInfo;\r\n            self.ready().then(function () {\r\n                dbInfo = self._dbInfo;\r\n                if (toString.call(value) === '[object Blob]') {\r\n                    return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\r\n                        if (blobSupport) {\r\n                            return value;\r\n                        }\r\n                        return _encodeBlob(value);\r\n                    });\r\n                }\r\n                return value;\r\n            }).then(function (value) {\r\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n    \r\n                        // The reason we don't _save_ null is because IE 10 does\r\n                        // not support saving the `null` type in IndexedDB. How\r\n                        // ironic, given the bug below!\r\n                        // See: https://github.com/mozilla/localForage/issues/161\r\n                        if (value === null) {\r\n                            value = undefined;\r\n                        }\r\n    \r\n                        var req = store.put(value, key);\r\n    \r\n                        transaction.oncomplete = function () {\r\n                            // Cast to undefined so the value passed to\r\n                            // callback/promise is the same as what one would get out\r\n                            // of `getItem()` later. This leads to some weirdness\r\n                            // (setItem('foo', undefined) will return `null`), but\r\n                            // it's not my fault localStorage is our baseline and that\r\n                            // it's weird.\r\n                            if (value === undefined) {\r\n                                value = null;\r\n                            }\r\n    \r\n                            resolve(value);\r\n                        };\r\n                        transaction.onabort = transaction.onerror = function () {\r\n                            var err = req.error ? req.error : req.transaction.error;\r\n                            reject(err);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function removeItem(key, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n                        // We use a Grunt task to make this safe for IE and some\r\n                        // versions of Android (including those used by Cordova).\r\n                        // Normally IE won't like `.delete()` and will insist on\r\n                        // using `['delete']()`, but we have a build step that\r\n                        // fixes this for us now.\r\n                        var req = store[\"delete\"](key);\r\n                        transaction.oncomplete = function () {\r\n                            resolve();\r\n                        };\r\n    \r\n                        transaction.onerror = function () {\r\n                            reject(req.error);\r\n                        };\r\n    \r\n                        // The request will be also be aborted if we've exceeded our storage\r\n                        // space.\r\n                        transaction.onabort = function () {\r\n                            var err = req.error ? req.error : req.transaction.error;\r\n                            reject(err);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function clear(callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n                        var req = store.clear();\r\n    \r\n                        transaction.oncomplete = function () {\r\n                            resolve();\r\n                        };\r\n    \r\n                        transaction.onabort = transaction.onerror = function () {\r\n                            var err = req.error ? req.error : req.transaction.error;\r\n                            reject(err);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function length(callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n                        var req = store.count();\r\n    \r\n                        req.onsuccess = function () {\r\n                            resolve(req.result);\r\n                        };\r\n    \r\n                        req.onerror = function () {\r\n                            reject(req.error);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function key(n, callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            if (n < 0) {\r\n                resolve(null);\r\n    \r\n                return;\r\n            }\r\n    \r\n            self.ready().then(function () {\r\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n                        var advanced = false;\r\n                        var req = store.openCursor();\r\n    \r\n                        req.onsuccess = function () {\r\n                            var cursor = req.result;\r\n                            if (!cursor) {\r\n                                // this means there weren't enough keys\r\n                                resolve(null);\r\n    \r\n                                return;\r\n                            }\r\n    \r\n                            if (n === 0) {\r\n                                // We have the first key, return it if that's what they\r\n                                // wanted.\r\n                                resolve(cursor.key);\r\n                            } else {\r\n                                if (!advanced) {\r\n                                    // Otherwise, ask the cursor to skip ahead n\r\n                                    // records.\r\n                                    advanced = true;\r\n                                    cursor.advance(n);\r\n                                } else {\r\n                                    // When we get here, we've got the nth key.\r\n                                    resolve(cursor.key);\r\n                                }\r\n                            }\r\n                        };\r\n    \r\n                        req.onerror = function () {\r\n                            reject(req.error);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function keys(callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\r\n                    if (err) {\r\n                        return reject(err);\r\n                    }\r\n    \r\n                    try {\r\n                        var store = transaction.objectStore(self._dbInfo.storeName);\r\n                        var req = store.openCursor();\r\n                        var keys = [];\r\n    \r\n                        req.onsuccess = function () {\r\n                            var cursor = req.result;\r\n    \r\n                            if (!cursor) {\r\n                                resolve(keys);\r\n                                return;\r\n                            }\r\n    \r\n                            keys.push(cursor.key);\r\n                            cursor[\"continue\"]();\r\n                        };\r\n    \r\n                        req.onerror = function () {\r\n                            reject(req.error);\r\n                        };\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function dropInstance(options, callback) {\r\n        callback = getCallback.apply(this, arguments);\r\n    \r\n        var currentConfig = this.config();\r\n        options = typeof options !== 'function' && options || {};\r\n        if (!options.name) {\r\n            options.name = options.name || currentConfig.name;\r\n            options.storeName = options.storeName || currentConfig.storeName;\r\n        }\r\n    \r\n        var self = this;\r\n        var promise;\r\n        if (!options.name) {\r\n            promise = Promise$1.reject('Invalid arguments');\r\n        } else {\r\n            var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\r\n    \r\n            var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\r\n                var dbContext = dbContexts[options.name];\r\n                var forages = dbContext.forages;\r\n                dbContext.db = db;\r\n                for (var i = 0; i < forages.length; i++) {\r\n                    forages[i]._dbInfo.db = db;\r\n                }\r\n                return db;\r\n            });\r\n    \r\n            if (!options.storeName) {\r\n                promise = dbPromise.then(function (db) {\r\n                    _deferReadiness(options);\r\n    \r\n                    var dbContext = dbContexts[options.name];\r\n                    var forages = dbContext.forages;\r\n    \r\n                    db.close();\r\n                    for (var i = 0; i < forages.length; i++) {\r\n                        var forage = forages[i];\r\n                        forage._dbInfo.db = null;\r\n                    }\r\n    \r\n                    var dropDBPromise = new Promise$1(function (resolve, reject) {\r\n                        var req = idb.deleteDatabase(options.name);\r\n    \r\n                        req.onerror = req.onblocked = function (err) {\r\n                            var db = req.result;\r\n                            if (db) {\r\n                                db.close();\r\n                            }\r\n                            reject(err);\r\n                        };\r\n    \r\n                        req.onsuccess = function () {\r\n                            var db = req.result;\r\n                            if (db) {\r\n                                db.close();\r\n                            }\r\n                            resolve(db);\r\n                        };\r\n                    });\r\n    \r\n                    return dropDBPromise.then(function (db) {\r\n                        dbContext.db = db;\r\n                        for (var i = 0; i < forages.length; i++) {\r\n                            var _forage = forages[i];\r\n                            _advanceReadiness(_forage._dbInfo);\r\n                        }\r\n                    })[\"catch\"](function (err) {\r\n                        (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\r\n                        throw err;\r\n                    });\r\n                });\r\n            } else {\r\n                promise = dbPromise.then(function (db) {\r\n                    if (!db.objectStoreNames.contains(options.storeName)) {\r\n                        return;\r\n                    }\r\n    \r\n                    var newVersion = db.version + 1;\r\n    \r\n                    _deferReadiness(options);\r\n    \r\n                    var dbContext = dbContexts[options.name];\r\n                    var forages = dbContext.forages;\r\n    \r\n                    db.close();\r\n                    for (var i = 0; i < forages.length; i++) {\r\n                        var forage = forages[i];\r\n                        forage._dbInfo.db = null;\r\n                        forage._dbInfo.version = newVersion;\r\n                    }\r\n    \r\n                    var dropObjectPromise = new Promise$1(function (resolve, reject) {\r\n                        var req = idb.open(options.name, newVersion);\r\n    \r\n                        req.onerror = function (err) {\r\n                            var db = req.result;\r\n                            db.close();\r\n                            reject(err);\r\n                        };\r\n    \r\n                        req.onupgradeneeded = function () {\r\n                            var db = req.result;\r\n                            db.deleteObjectStore(options.storeName);\r\n                        };\r\n    \r\n                        req.onsuccess = function () {\r\n                            var db = req.result;\r\n                            db.close();\r\n                            resolve(db);\r\n                        };\r\n                    });\r\n    \r\n                    return dropObjectPromise.then(function (db) {\r\n                        dbContext.db = db;\r\n                        for (var j = 0; j < forages.length; j++) {\r\n                            var _forage2 = forages[j];\r\n                            _forage2._dbInfo.db = db;\r\n                            _advanceReadiness(_forage2._dbInfo);\r\n                        }\r\n                    })[\"catch\"](function (err) {\r\n                        (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\r\n                        throw err;\r\n                    });\r\n                });\r\n            }\r\n        }\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    var asyncStorage = {\r\n        _driver: 'asyncStorage',\r\n        _initStorage: _initStorage,\r\n        _support: isIndexedDBValid(),\r\n        iterate: iterate,\r\n        getItem: getItem,\r\n        setItem: setItem,\r\n        removeItem: removeItem,\r\n        clear: clear,\r\n        length: length,\r\n        key: key,\r\n        keys: keys,\r\n        dropInstance: dropInstance\r\n    };\r\n    \r\n    function isWebSQLValid() {\r\n        return typeof openDatabase === 'function';\r\n    }\r\n    \r\n    // Sadly, the best way to save binary data in WebSQL/localStorage is serializing\r\n    // it to Base64, so this is how we store it to prevent very strange errors with less\r\n    // verbose ways of binary <-> string data storage.\r\n    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n    \r\n    var BLOB_TYPE_PREFIX = '~~local_forage_type~';\r\n    var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\r\n    \r\n    var SERIALIZED_MARKER = '__lfsc__:';\r\n    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\r\n    \r\n    // OMG the serializations!\r\n    var TYPE_ARRAYBUFFER = 'arbf';\r\n    var TYPE_BLOB = 'blob';\r\n    var TYPE_INT8ARRAY = 'si08';\r\n    var TYPE_UINT8ARRAY = 'ui08';\r\n    var TYPE_UINT8CLAMPEDARRAY = 'uic8';\r\n    var TYPE_INT16ARRAY = 'si16';\r\n    var TYPE_INT32ARRAY = 'si32';\r\n    var TYPE_UINT16ARRAY = 'ur16';\r\n    var TYPE_UINT32ARRAY = 'ui32';\r\n    var TYPE_FLOAT32ARRAY = 'fl32';\r\n    var TYPE_FLOAT64ARRAY = 'fl64';\r\n    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\r\n    \r\n    var toString$1 = Object.prototype.toString;\r\n    \r\n    function stringToBuffer(serializedString) {\r\n        // Fill the string into a ArrayBuffer.\r\n        var bufferLength = serializedString.length * 0.75;\r\n        var len = serializedString.length;\r\n        var i;\r\n        var p = 0;\r\n        var encoded1, encoded2, encoded3, encoded4;\r\n    \r\n        if (serializedString[serializedString.length - 1] === '=') {\r\n            bufferLength--;\r\n            if (serializedString[serializedString.length - 2] === '=') {\r\n                bufferLength--;\r\n            }\r\n        }\r\n    \r\n        var buffer = new ArrayBuffer(bufferLength);\r\n        var bytes = new Uint8Array(buffer);\r\n    \r\n        for (i = 0; i < len; i += 4) {\r\n            encoded1 = BASE_CHARS.indexOf(serializedString[i]);\r\n            encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\r\n            encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\r\n            encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\r\n    \r\n            /*jslint bitwise: true */\r\n            bytes[p++] = encoded1 << 2 | encoded2 >> 4;\r\n            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\r\n            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\r\n        }\r\n        return buffer;\r\n    }\r\n    \r\n    // Converts a buffer to a string to store, serialized, in the backend\r\n    // storage library.\r\n    function bufferToString(buffer) {\r\n        // base64-arraybuffer\r\n        var bytes = new Uint8Array(buffer);\r\n        var base64String = '';\r\n        var i;\r\n    \r\n        for (i = 0; i < bytes.length; i += 3) {\r\n            /*jslint bitwise: true */\r\n            base64String += BASE_CHARS[bytes[i] >> 2];\r\n            base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\r\n            base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\r\n            base64String += BASE_CHARS[bytes[i + 2] & 63];\r\n        }\r\n    \r\n        if (bytes.length % 3 === 2) {\r\n            base64String = base64String.substring(0, base64String.length - 1) + '=';\r\n        } else if (bytes.length % 3 === 1) {\r\n            base64String = base64String.substring(0, base64String.length - 2) + '==';\r\n        }\r\n    \r\n        return base64String;\r\n    }\r\n    \r\n    // Serialize a value, afterwards executing a callback (which usually\r\n    // instructs the `setItem()` callback/promise to be executed). This is how\r\n    // we store binary data with localStorage.\r\n    function serialize(value, callback) {\r\n        var valueType = '';\r\n        if (value) {\r\n            valueType = toString$1.call(value);\r\n        }\r\n    \r\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\r\n        // checks fail when running the tests using casper.js...\r\n        //\r\n        // TODO: See why those tests fail and use a better solution.\r\n        if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\r\n            // Convert binary arrays to a string and prefix the string with\r\n            // a special marker.\r\n            var buffer;\r\n            var marker = SERIALIZED_MARKER;\r\n    \r\n            if (value instanceof ArrayBuffer) {\r\n                buffer = value;\r\n                marker += TYPE_ARRAYBUFFER;\r\n            } else {\r\n                buffer = value.buffer;\r\n    \r\n                if (valueType === '[object Int8Array]') {\r\n                    marker += TYPE_INT8ARRAY;\r\n                } else if (valueType === '[object Uint8Array]') {\r\n                    marker += TYPE_UINT8ARRAY;\r\n                } else if (valueType === '[object Uint8ClampedArray]') {\r\n                    marker += TYPE_UINT8CLAMPEDARRAY;\r\n                } else if (valueType === '[object Int16Array]') {\r\n                    marker += TYPE_INT16ARRAY;\r\n                } else if (valueType === '[object Uint16Array]') {\r\n                    marker += TYPE_UINT16ARRAY;\r\n                } else if (valueType === '[object Int32Array]') {\r\n                    marker += TYPE_INT32ARRAY;\r\n                } else if (valueType === '[object Uint32Array]') {\r\n                    marker += TYPE_UINT32ARRAY;\r\n                } else if (valueType === '[object Float32Array]') {\r\n                    marker += TYPE_FLOAT32ARRAY;\r\n                } else if (valueType === '[object Float64Array]') {\r\n                    marker += TYPE_FLOAT64ARRAY;\r\n                } else {\r\n                    callback(new Error('Failed to get type for BinaryArray'));\r\n                }\r\n            }\r\n    \r\n            callback(marker + bufferToString(buffer));\r\n        } else if (valueType === '[object Blob]') {\r\n            // Conver the blob to a binaryArray and then to a string.\r\n            var fileReader = new FileReader();\r\n    \r\n            fileReader.onload = function () {\r\n                // Backwards-compatible prefix for the blob type.\r\n                var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\r\n    \r\n                callback(SERIALIZED_MARKER + TYPE_BLOB + str);\r\n            };\r\n    \r\n            fileReader.readAsArrayBuffer(value);\r\n        } else {\r\n            try {\r\n                callback(JSON.stringify(value));\r\n            } catch (e) {\r\n                console.error(\"Couldn't convert value into a JSON string: \", value);\r\n    \r\n                callback(null, e);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Deserialize data we've inserted into a value column/field. We place\r\n    // special markers into our strings to mark them as encoded; this isn't\r\n    // as nice as a meta field, but it's the only sane thing we can do whilst\r\n    // keeping localStorage support intact.\r\n    //\r\n    // Oftentimes this will just deserialize JSON content, but if we have a\r\n    // special marker (SERIALIZED_MARKER, defined above), we will extract\r\n    // some kind of arraybuffer/binary data/typed array out of the string.\r\n    function deserialize(value) {\r\n        // If we haven't marked this string as being specially serialized (i.e.\r\n        // something other than serialized JSON), we can just return it and be\r\n        // done with it.\r\n        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\r\n            return JSON.parse(value);\r\n        }\r\n    \r\n        // The following code deals with deserializing some kind of Blob or\r\n        // TypedArray. First we separate out the type of data we're dealing\r\n        // with from the data itself.\r\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\r\n        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\r\n    \r\n        var blobType;\r\n        // Backwards-compatible blob type serialization strategy.\r\n        // DBs created with older versions of localForage will simply not have the blob type.\r\n        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\r\n            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\r\n            blobType = matcher[1];\r\n            serializedString = serializedString.substring(matcher[0].length);\r\n        }\r\n        var buffer = stringToBuffer(serializedString);\r\n    \r\n        // Return the right type based on the code/type set during\r\n        // serialization.\r\n        switch (type) {\r\n            case TYPE_ARRAYBUFFER:\r\n                return buffer;\r\n            case TYPE_BLOB:\r\n                return createBlob([buffer], { type: blobType });\r\n            case TYPE_INT8ARRAY:\r\n                return new Int8Array(buffer);\r\n            case TYPE_UINT8ARRAY:\r\n                return new Uint8Array(buffer);\r\n            case TYPE_UINT8CLAMPEDARRAY:\r\n                return new Uint8ClampedArray(buffer);\r\n            case TYPE_INT16ARRAY:\r\n                return new Int16Array(buffer);\r\n            case TYPE_UINT16ARRAY:\r\n                return new Uint16Array(buffer);\r\n            case TYPE_INT32ARRAY:\r\n                return new Int32Array(buffer);\r\n            case TYPE_UINT32ARRAY:\r\n                return new Uint32Array(buffer);\r\n            case TYPE_FLOAT32ARRAY:\r\n                return new Float32Array(buffer);\r\n            case TYPE_FLOAT64ARRAY:\r\n                return new Float64Array(buffer);\r\n            default:\r\n                throw new Error('Unkown type: ' + type);\r\n        }\r\n    }\r\n    \r\n    var localforageSerializer = {\r\n        serialize: serialize,\r\n        deserialize: deserialize,\r\n        stringToBuffer: stringToBuffer,\r\n        bufferToString: bufferToString\r\n    };\r\n    \r\n    /*\r\n     * Includes code from:\r\n     *\r\n     * base64-arraybuffer\r\n     * https://github.com/niklasvh/base64-arraybuffer\r\n     *\r\n     * Copyright (c) 2012 Niklas von Hertzen\r\n     * Licensed under the MIT license.\r\n     */\r\n    \r\n    function createDbTable(t, dbInfo, callback, errorCallback) {\r\n        t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\r\n    }\r\n    \r\n    // Open the WebSQL database (automatically creates one if one didn't\r\n    // previously exist), using any options set in the config.\r\n    function _initStorage$1(options) {\r\n        var self = this;\r\n        var dbInfo = {\r\n            db: null\r\n        };\r\n    \r\n        if (options) {\r\n            for (var i in options) {\r\n                dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\r\n            }\r\n        }\r\n    \r\n        var dbInfoPromise = new Promise$1(function (resolve, reject) {\r\n            // Open the database; the openDatabase API will automatically\r\n            // create it for us if it doesn't exist.\r\n            try {\r\n                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\r\n            } catch (e) {\r\n                return reject(e);\r\n            }\r\n    \r\n            // Create our key/value table if it doesn't exist.\r\n            dbInfo.db.transaction(function (t) {\r\n                createDbTable(t, dbInfo, function () {\r\n                    self._dbInfo = dbInfo;\r\n                    resolve();\r\n                }, function (t, error) {\r\n                    reject(error);\r\n                });\r\n            }, reject);\r\n        });\r\n    \r\n        dbInfo.serializer = localforageSerializer;\r\n        return dbInfoPromise;\r\n    }\r\n    \r\n    function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\r\n        t.executeSql(sqlStatement, args, callback, function (t, error) {\r\n            if (error.code === error.SYNTAX_ERR) {\r\n                t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [name], function (t, results) {\r\n                    if (!results.rows.length) {\r\n                        // if the table is missing (was deleted)\r\n                        // re-create it table and retry\r\n                        createDbTable(t, dbInfo, function () {\r\n                            t.executeSql(sqlStatement, args, callback, errorCallback);\r\n                        }, errorCallback);\r\n                    } else {\r\n                        errorCallback(t, error);\r\n                    }\r\n                }, errorCallback);\r\n            } else {\r\n                errorCallback(t, error);\r\n            }\r\n        }, errorCallback);\r\n    }\r\n    \r\n    function getItem$1(key, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.db.transaction(function (t) {\r\n                    tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\r\n                        var result = results.rows.length ? results.rows.item(0).value : null;\r\n    \r\n                        // Check to see if this is serialized content we need to\r\n                        // unpack.\r\n                        if (result) {\r\n                            result = dbInfo.serializer.deserialize(result);\r\n                        }\r\n    \r\n                        resolve(result);\r\n                    }, function (t, error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function iterate$1(iterator, callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var dbInfo = self._dbInfo;\r\n    \r\n                dbInfo.db.transaction(function (t) {\r\n                    tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\r\n                        var rows = results.rows;\r\n                        var length = rows.length;\r\n    \r\n                        for (var i = 0; i < length; i++) {\r\n                            var item = rows.item(i);\r\n                            var result = item.value;\r\n    \r\n                            // Check to see if this is serialized content\r\n                            // we need to unpack.\r\n                            if (result) {\r\n                                result = dbInfo.serializer.deserialize(result);\r\n                            }\r\n    \r\n                            result = iterator(result, item.key, i + 1);\r\n    \r\n                            // void(0) prevents problems with redefinition\r\n                            // of `undefined`.\r\n                            if (result !== void 0) {\r\n                                resolve(result);\r\n                                return;\r\n                            }\r\n                        }\r\n    \r\n                        resolve();\r\n                    }, function (t, error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function _setItem(key, value, callback, retriesLeft) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                // The localStorage API doesn't return undefined values in an\r\n                // \"expected\" way, so undefined is always cast to null in all\r\n                // drivers. See: https://github.com/mozilla/localForage/pull/42\r\n                if (value === undefined) {\r\n                    value = null;\r\n                }\r\n    \r\n                // Save the original value to pass to the callback.\r\n                var originalValue = value;\r\n    \r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.serializer.serialize(value, function (value, error) {\r\n                    if (error) {\r\n                        reject(error);\r\n                    } else {\r\n                        dbInfo.db.transaction(function (t) {\r\n                            tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\r\n                                resolve(originalValue);\r\n                            }, function (t, error) {\r\n                                reject(error);\r\n                            });\r\n                        }, function (sqlError) {\r\n                            // The transaction failed; check\r\n                            // to see if it's a quota error.\r\n                            if (sqlError.code === sqlError.QUOTA_ERR) {\r\n                                // We reject the callback outright for now, but\r\n                                // it's worth trying to re-run the transaction.\r\n                                // Even if the user accepts the prompt to use\r\n                                // more storage on Safari, this error will\r\n                                // be called.\r\n                                //\r\n                                // Try to re-run the transaction.\r\n                                if (retriesLeft > 0) {\r\n                                    resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\r\n                                    return;\r\n                                }\r\n                                reject(sqlError);\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function setItem$1(key, value, callback) {\r\n        return _setItem.apply(this, [key, value, callback, 1]);\r\n    }\r\n    \r\n    function removeItem$1(key, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.db.transaction(function (t) {\r\n                    tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\r\n                        resolve();\r\n                    }, function (t, error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Deletes every item in the table.\r\n    // TODO: Find out if this resets the AUTO_INCREMENT number.\r\n    function clear$1(callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.db.transaction(function (t) {\r\n                    tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\r\n                        resolve();\r\n                    }, function (t, error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Does a simple `COUNT(key)` to get the number of items stored in\r\n    // localForage.\r\n    function length$1(callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.db.transaction(function (t) {\r\n                    // Ahhh, SQL makes this one soooooo easy.\r\n                    tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\r\n                        var result = results.rows.item(0).c;\r\n                        resolve(result);\r\n                    }, function (t, error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Return the key located at key index X; essentially gets the key from a\r\n    // `WHERE id = ?`. This is the most efficient way I can think to implement\r\n    // this rarely-used (in my experience) part of the API, but it can seem\r\n    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\r\n    // the ID of each key will change every time it's updated. Perhaps a stored\r\n    // procedure for the `setItem()` SQL would solve this problem?\r\n    // TODO: Don't change ID on `setItem()`.\r\n    function key$1(n, callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.db.transaction(function (t) {\r\n                    tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\r\n                        var result = results.rows.length ? results.rows.item(0).key : null;\r\n                        resolve(result);\r\n                    }, function (t, error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function keys$1(callback) {\r\n        var self = this;\r\n    \r\n        var promise = new Promise$1(function (resolve, reject) {\r\n            self.ready().then(function () {\r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.db.transaction(function (t) {\r\n                    tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\r\n                        var keys = [];\r\n    \r\n                        for (var i = 0; i < results.rows.length; i++) {\r\n                            keys.push(results.rows.item(i).key);\r\n                        }\r\n    \r\n                        resolve(keys);\r\n                    }, function (t, error) {\r\n                        reject(error);\r\n                    });\r\n                });\r\n            })[\"catch\"](reject);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // https://www.w3.org/TR/webdatabase/#databases\r\n    // > There is no way to enumerate or delete the databases available for an origin from this API.\r\n    function getAllStoreNames(db) {\r\n        return new Promise$1(function (resolve, reject) {\r\n            db.transaction(function (t) {\r\n                t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\r\n                    var storeNames = [];\r\n    \r\n                    for (var i = 0; i < results.rows.length; i++) {\r\n                        storeNames.push(results.rows.item(i).name);\r\n                    }\r\n    \r\n                    resolve({\r\n                        db: db,\r\n                        storeNames: storeNames\r\n                    });\r\n                }, function (t, error) {\r\n                    reject(error);\r\n                });\r\n            }, function (sqlError) {\r\n                reject(sqlError);\r\n            });\r\n        });\r\n    }\r\n    \r\n    function dropInstance$1(options, callback) {\r\n        callback = getCallback.apply(this, arguments);\r\n    \r\n        var currentConfig = this.config();\r\n        options = typeof options !== 'function' && options || {};\r\n        if (!options.name) {\r\n            options.name = options.name || currentConfig.name;\r\n            options.storeName = options.storeName || currentConfig.storeName;\r\n        }\r\n    \r\n        var self = this;\r\n        var promise;\r\n        if (!options.name) {\r\n            promise = Promise$1.reject('Invalid arguments');\r\n        } else {\r\n            promise = new Promise$1(function (resolve) {\r\n                var db;\r\n                if (options.name === currentConfig.name) {\r\n                    // use the db reference of the current instance\r\n                    db = self._dbInfo.db;\r\n                } else {\r\n                    db = openDatabase(options.name, '', '', 0);\r\n                }\r\n    \r\n                if (!options.storeName) {\r\n                    // drop all database tables\r\n                    resolve(getAllStoreNames(db));\r\n                } else {\r\n                    resolve({\r\n                        db: db,\r\n                        storeNames: [options.storeName]\r\n                    });\r\n                }\r\n            }).then(function (operationInfo) {\r\n                return new Promise$1(function (resolve, reject) {\r\n                    operationInfo.db.transaction(function (t) {\r\n                        function dropTable(storeName) {\r\n                            return new Promise$1(function (resolve, reject) {\r\n                                t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\r\n                                    resolve();\r\n                                }, function (t, error) {\r\n                                    reject(error);\r\n                                });\r\n                            });\r\n                        }\r\n    \r\n                        var operations = [];\r\n                        for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\r\n                            operations.push(dropTable(operationInfo.storeNames[i]));\r\n                        }\r\n    \r\n                        Promise$1.all(operations).then(function () {\r\n                            resolve();\r\n                        })[\"catch\"](function (e) {\r\n                            reject(e);\r\n                        });\r\n                    }, function (sqlError) {\r\n                        reject(sqlError);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    var webSQLStorage = {\r\n        _driver: 'webSQLStorage',\r\n        _initStorage: _initStorage$1,\r\n        _support: isWebSQLValid(),\r\n        iterate: iterate$1,\r\n        getItem: getItem$1,\r\n        setItem: setItem$1,\r\n        removeItem: removeItem$1,\r\n        clear: clear$1,\r\n        length: length$1,\r\n        key: key$1,\r\n        keys: keys$1,\r\n        dropInstance: dropInstance$1\r\n    };\r\n    \r\n    function isLocalStorageValid() {\r\n        try {\r\n            return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\r\n            // in IE8 typeof localStorage.setItem === 'object'\r\n            !!localStorage.setItem;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function _getKeyPrefix(options, defaultConfig) {\r\n        var keyPrefix = options.name + '/';\r\n    \r\n        if (options.storeName !== defaultConfig.storeName) {\r\n            keyPrefix += options.storeName + '/';\r\n        }\r\n        return keyPrefix;\r\n    }\r\n    \r\n    // Check if localStorage throws when saving an item\r\n    function checkIfLocalStorageThrows() {\r\n        var localStorageTestKey = '_localforage_support_test';\r\n    \r\n        try {\r\n            localStorage.setItem(localStorageTestKey, true);\r\n            localStorage.removeItem(localStorageTestKey);\r\n    \r\n            return false;\r\n        } catch (e) {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    // Check if localStorage is usable and allows to save an item\r\n    // This method checks if localStorage is usable in Safari Private Browsing\r\n    // mode, or in any other case where the available quota for localStorage\r\n    // is 0 and there wasn't any saved items yet.\r\n    function _isLocalStorageUsable() {\r\n        return !checkIfLocalStorageThrows() || localStorage.length > 0;\r\n    }\r\n    \r\n    // Config the localStorage backend, using options set in the config.\r\n    function _initStorage$2(options) {\r\n        var self = this;\r\n        var dbInfo = {};\r\n        if (options) {\r\n            for (var i in options) {\r\n                dbInfo[i] = options[i];\r\n            }\r\n        }\r\n    \r\n        dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\r\n    \r\n        if (!_isLocalStorageUsable()) {\r\n            return Promise$1.reject();\r\n        }\r\n    \r\n        self._dbInfo = dbInfo;\r\n        dbInfo.serializer = localforageSerializer;\r\n    \r\n        return Promise$1.resolve();\r\n    }\r\n    \r\n    // Remove all keys from the datastore, effectively destroying all data in\r\n    // the app's key/value store!\r\n    function clear$2(callback) {\r\n        var self = this;\r\n        var promise = self.ready().then(function () {\r\n            var keyPrefix = self._dbInfo.keyPrefix;\r\n    \r\n            for (var i = localStorage.length - 1; i >= 0; i--) {\r\n                var key = localStorage.key(i);\r\n    \r\n                if (key.indexOf(keyPrefix) === 0) {\r\n                    localStorage.removeItem(key);\r\n                }\r\n            }\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Retrieve an item from the store. Unlike the original async_storage\r\n    // library in Gaia, we don't modify return values at all. If a key's value\r\n    // is `undefined`, we pass that value to the callback function.\r\n    function getItem$2(key, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var result = localStorage.getItem(dbInfo.keyPrefix + key);\r\n    \r\n            // If a result was found, parse it from the serialized\r\n            // string into a JS object. If result isn't truthy, the key\r\n            // is likely undefined and we'll pass it straight to the\r\n            // callback.\r\n            if (result) {\r\n                result = dbInfo.serializer.deserialize(result);\r\n            }\r\n    \r\n            return result;\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Iterate over all items in the store.\r\n    function iterate$2(iterator, callback) {\r\n        var self = this;\r\n    \r\n        var promise = self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var keyPrefix = dbInfo.keyPrefix;\r\n            var keyPrefixLength = keyPrefix.length;\r\n            var length = localStorage.length;\r\n    \r\n            // We use a dedicated iterator instead of the `i` variable below\r\n            // so other keys we fetch in localStorage aren't counted in\r\n            // the `iterationNumber` argument passed to the `iterate()`\r\n            // callback.\r\n            //\r\n            // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\r\n            var iterationNumber = 1;\r\n    \r\n            for (var i = 0; i < length; i++) {\r\n                var key = localStorage.key(i);\r\n                if (key.indexOf(keyPrefix) !== 0) {\r\n                    continue;\r\n                }\r\n                var value = localStorage.getItem(key);\r\n    \r\n                // If a result was found, parse it from the serialized\r\n                // string into a JS object. If result isn't truthy, the\r\n                // key is likely undefined and we'll pass it straight\r\n                // to the iterator.\r\n                if (value) {\r\n                    value = dbInfo.serializer.deserialize(value);\r\n                }\r\n    \r\n                value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\r\n    \r\n                if (value !== void 0) {\r\n                    return value;\r\n                }\r\n            }\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Same as localStorage's key() method, except takes a callback.\r\n    function key$2(n, callback) {\r\n        var self = this;\r\n        var promise = self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var result;\r\n            try {\r\n                result = localStorage.key(n);\r\n            } catch (error) {\r\n                result = null;\r\n            }\r\n    \r\n            // Remove the prefix from the key, if a key is found.\r\n            if (result) {\r\n                result = result.substring(dbInfo.keyPrefix.length);\r\n            }\r\n    \r\n            return result;\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function keys$2(callback) {\r\n        var self = this;\r\n        var promise = self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            var length = localStorage.length;\r\n            var keys = [];\r\n    \r\n            for (var i = 0; i < length; i++) {\r\n                var itemKey = localStorage.key(i);\r\n                if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\r\n                    keys.push(itemKey.substring(dbInfo.keyPrefix.length));\r\n                }\r\n            }\r\n    \r\n            return keys;\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Supply the number of keys in the datastore to the callback function.\r\n    function length$2(callback) {\r\n        var self = this;\r\n        var promise = self.keys().then(function (keys) {\r\n            return keys.length;\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Remove an item from the store, nice and simple.\r\n    function removeItem$2(key, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = self.ready().then(function () {\r\n            var dbInfo = self._dbInfo;\r\n            localStorage.removeItem(dbInfo.keyPrefix + key);\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    // Set a key's value and run an optional callback once the value is set.\r\n    // Unlike Gaia's implementation, the callback function is passed the value,\r\n    // in case you want to operate on that value only after you're sure it\r\n    // saved, or something like that.\r\n    function setItem$2(key, value, callback) {\r\n        var self = this;\r\n    \r\n        key = normalizeKey(key);\r\n    \r\n        var promise = self.ready().then(function () {\r\n            // Convert undefined values to null.\r\n            // https://github.com/mozilla/localForage/pull/42\r\n            if (value === undefined) {\r\n                value = null;\r\n            }\r\n    \r\n            // Save the original value to pass to the callback.\r\n            var originalValue = value;\r\n    \r\n            return new Promise$1(function (resolve, reject) {\r\n                var dbInfo = self._dbInfo;\r\n                dbInfo.serializer.serialize(value, function (value, error) {\r\n                    if (error) {\r\n                        reject(error);\r\n                    } else {\r\n                        try {\r\n                            localStorage.setItem(dbInfo.keyPrefix + key, value);\r\n                            resolve(originalValue);\r\n                        } catch (e) {\r\n                            // localStorage capacity exceeded.\r\n                            // TODO: Make this a specific error/event.\r\n                            if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\r\n                                reject(e);\r\n                            }\r\n                            reject(e);\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    function dropInstance$2(options, callback) {\r\n        callback = getCallback.apply(this, arguments);\r\n    \r\n        options = typeof options !== 'function' && options || {};\r\n        if (!options.name) {\r\n            var currentConfig = this.config();\r\n            options.name = options.name || currentConfig.name;\r\n            options.storeName = options.storeName || currentConfig.storeName;\r\n        }\r\n    \r\n        var self = this;\r\n        var promise;\r\n        if (!options.name) {\r\n            promise = Promise$1.reject('Invalid arguments');\r\n        } else {\r\n            promise = new Promise$1(function (resolve) {\r\n                if (!options.storeName) {\r\n                    resolve(options.name + '/');\r\n                } else {\r\n                    resolve(_getKeyPrefix(options, self._defaultConfig));\r\n                }\r\n            }).then(function (keyPrefix) {\r\n                for (var i = localStorage.length - 1; i >= 0; i--) {\r\n                    var key = localStorage.key(i);\r\n    \r\n                    if (key.indexOf(keyPrefix) === 0) {\r\n                        localStorage.removeItem(key);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    \r\n        executeCallback(promise, callback);\r\n        return promise;\r\n    }\r\n    \r\n    var localStorageWrapper = {\r\n        _driver: 'localStorageWrapper',\r\n        _initStorage: _initStorage$2,\r\n        _support: isLocalStorageValid(),\r\n        iterate: iterate$2,\r\n        getItem: getItem$2,\r\n        setItem: setItem$2,\r\n        removeItem: removeItem$2,\r\n        clear: clear$2,\r\n        length: length$2,\r\n        key: key$2,\r\n        keys: keys$2,\r\n        dropInstance: dropInstance$2\r\n    };\r\n    \r\n    var sameValue = function sameValue(x, y) {\r\n        return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\r\n    };\r\n    \r\n    var includes = function includes(array, searchElement) {\r\n        var len = array.length;\r\n        var i = 0;\r\n        while (i < len) {\r\n            if (sameValue(array[i], searchElement)) {\r\n                return true;\r\n            }\r\n            i++;\r\n        }\r\n    \r\n        return false;\r\n    };\r\n    \r\n    var isArray = Array.isArray || function (arg) {\r\n        return Object.prototype.toString.call(arg) === '[object Array]';\r\n    };\r\n    \r\n    // Drivers are stored here when `defineDriver()` is called.\r\n    // They are shared across all instances of localForage.\r\n    var DefinedDrivers = {};\r\n    \r\n    var DriverSupport = {};\r\n    \r\n    var DefaultDrivers = {\r\n        INDEXEDDB: asyncStorage,\r\n        WEBSQL: webSQLStorage,\r\n        LOCALSTORAGE: localStorageWrapper\r\n    };\r\n    \r\n    var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\r\n    \r\n    var OptionalDriverMethods = ['dropInstance'];\r\n    \r\n    var LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\r\n    \r\n    var DefaultConfig = {\r\n        description: '',\r\n        driver: DefaultDriverOrder.slice(),\r\n        name: 'localforage',\r\n        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\r\n        // we can use without a prompt.\r\n        size: 4980736,\r\n        storeName: 'keyvaluepairs',\r\n        version: 1.0\r\n    };\r\n    \r\n    function callWhenReady(localForageInstance, libraryMethod) {\r\n        localForageInstance[libraryMethod] = function () {\r\n            var _args = arguments;\r\n            return localForageInstance.ready().then(function () {\r\n                return localForageInstance[libraryMethod].apply(localForageInstance, _args);\r\n            });\r\n        };\r\n    }\r\n    \r\n    function extend() {\r\n        for (var i = 1; i < arguments.length; i++) {\r\n            var arg = arguments[i];\r\n    \r\n            if (arg) {\r\n                for (var _key in arg) {\r\n                    if (arg.hasOwnProperty(_key)) {\r\n                        if (isArray(arg[_key])) {\r\n                            arguments[0][_key] = arg[_key].slice();\r\n                        } else {\r\n                            arguments[0][_key] = arg[_key];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    \r\n        return arguments[0];\r\n    }\r\n    \r\n    var LocalForage = function () {\r\n        function LocalForage(options) {\r\n            _classCallCheck(this, LocalForage);\r\n    \r\n            for (var driverTypeKey in DefaultDrivers) {\r\n                if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\r\n                    var driver = DefaultDrivers[driverTypeKey];\r\n                    var driverName = driver._driver;\r\n                    this[driverTypeKey] = driverName;\r\n    \r\n                    if (!DefinedDrivers[driverName]) {\r\n                        // we don't need to wait for the promise,\r\n                        // since the default drivers can be defined\r\n                        // in a blocking manner\r\n                        this.defineDriver(driver);\r\n                    }\r\n                }\r\n            }\r\n    \r\n            this._defaultConfig = extend({}, DefaultConfig);\r\n            this._config = extend({}, this._defaultConfig, options);\r\n            this._driverSet = null;\r\n            this._initDriver = null;\r\n            this._ready = false;\r\n            this._dbInfo = null;\r\n    \r\n            this._wrapLibraryMethodsWithReady();\r\n            this.setDriver(this._config.driver)[\"catch\"](function () {});\r\n        }\r\n    \r\n        // Set any config values for localForage; can be called anytime before\r\n        // the first API call (e.g. `getItem`, `setItem`).\r\n        // We loop through options so we don't overwrite existing config\r\n        // values.\r\n    \r\n    \r\n        LocalForage.prototype.config = function config(options) {\r\n            // If the options argument is an object, we use it to set values.\r\n            // Otherwise, we return either a specified config value or all\r\n            // config values.\r\n            if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\r\n                // If localforage is ready and fully initialized, we can't set\r\n                // any new configuration values. Instead, we return an error.\r\n                if (this._ready) {\r\n                    return new Error(\"Can't call config() after localforage \" + 'has been used.');\r\n                }\r\n    \r\n                for (var i in options) {\r\n                    if (i === 'storeName') {\r\n                        options[i] = options[i].replace(/\\W/g, '_');\r\n                    }\r\n    \r\n                    if (i === 'version' && typeof options[i] !== 'number') {\r\n                        return new Error('Database version must be a number.');\r\n                    }\r\n    \r\n                    this._config[i] = options[i];\r\n                }\r\n    \r\n                // after all config options are set and\r\n                // the driver option is used, try setting it\r\n                if ('driver' in options && options.driver) {\r\n                    return this.setDriver(this._config.driver);\r\n                }\r\n    \r\n                return true;\r\n            } else if (typeof options === 'string') {\r\n                return this._config[options];\r\n            } else {\r\n                return this._config;\r\n            }\r\n        };\r\n    \r\n        // Used to define a custom driver, shared across all instances of\r\n        // localForage.\r\n    \r\n    \r\n        LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\r\n            var promise = new Promise$1(function (resolve, reject) {\r\n                try {\r\n                    var driverName = driverObject._driver;\r\n                    var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\r\n    \r\n                    // A driver name should be defined and not overlap with the\r\n                    // library-defined, default drivers.\r\n                    if (!driverObject._driver) {\r\n                        reject(complianceError);\r\n                        return;\r\n                    }\r\n    \r\n                    var driverMethods = LibraryMethods.concat('_initStorage');\r\n                    for (var i = 0, len = driverMethods.length; i < len; i++) {\r\n                        var driverMethodName = driverMethods[i];\r\n    \r\n                        // when the property is there,\r\n                        // it should be a method even when optional\r\n                        var isRequired = !includes(OptionalDriverMethods, driverMethodName);\r\n                        if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\r\n                            reject(complianceError);\r\n                            return;\r\n                        }\r\n                    }\r\n    \r\n                    var configureMissingMethods = function configureMissingMethods() {\r\n                        var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\r\n                            return function () {\r\n                                var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\r\n                                var promise = Promise$1.reject(error);\r\n                                executeCallback(promise, arguments[arguments.length - 1]);\r\n                                return promise;\r\n                            };\r\n                        };\r\n    \r\n                        for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\r\n                            var optionalDriverMethod = OptionalDriverMethods[_i];\r\n                            if (!driverObject[optionalDriverMethod]) {\r\n                                driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\r\n                            }\r\n                        }\r\n                    };\r\n    \r\n                    configureMissingMethods();\r\n    \r\n                    var setDriverSupport = function setDriverSupport(support) {\r\n                        if (DefinedDrivers[driverName]) {\r\n                            console.info('Redefining LocalForage driver: ' + driverName);\r\n                        }\r\n                        DefinedDrivers[driverName] = driverObject;\r\n                        DriverSupport[driverName] = support;\r\n                        // don't use a then, so that we can define\r\n                        // drivers that have simple _support methods\r\n                        // in a blocking manner\r\n                        resolve();\r\n                    };\r\n    \r\n                    if ('_support' in driverObject) {\r\n                        if (driverObject._support && typeof driverObject._support === 'function') {\r\n                            driverObject._support().then(setDriverSupport, reject);\r\n                        } else {\r\n                            setDriverSupport(!!driverObject._support);\r\n                        }\r\n                    } else {\r\n                        setDriverSupport(true);\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n    \r\n            executeTwoCallbacks(promise, callback, errorCallback);\r\n            return promise;\r\n        };\r\n    \r\n        LocalForage.prototype.driver = function driver() {\r\n            return this._driver || null;\r\n        };\r\n    \r\n        LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\r\n            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\r\n    \r\n            executeTwoCallbacks(getDriverPromise, callback, errorCallback);\r\n            return getDriverPromise;\r\n        };\r\n    \r\n        LocalForage.prototype.getSerializer = function getSerializer(callback) {\r\n            var serializerPromise = Promise$1.resolve(localforageSerializer);\r\n            executeTwoCallbacks(serializerPromise, callback);\r\n            return serializerPromise;\r\n        };\r\n    \r\n        LocalForage.prototype.ready = function ready(callback) {\r\n            var self = this;\r\n    \r\n            var promise = self._driverSet.then(function () {\r\n                if (self._ready === null) {\r\n                    self._ready = self._initDriver();\r\n                }\r\n    \r\n                return self._ready;\r\n            });\r\n    \r\n            executeTwoCallbacks(promise, callback, callback);\r\n            return promise;\r\n        };\r\n    \r\n        LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\r\n            var self = this;\r\n    \r\n            if (!isArray(drivers)) {\r\n                drivers = [drivers];\r\n            }\r\n    \r\n            var supportedDrivers = this._getSupportedDrivers(drivers);\r\n    \r\n            function setDriverToConfig() {\r\n                self._config.driver = self.driver();\r\n            }\r\n    \r\n            function extendSelfWithDriver(driver) {\r\n                self._extend(driver);\r\n                setDriverToConfig();\r\n    \r\n                self._ready = self._initStorage(self._config);\r\n                return self._ready;\r\n            }\r\n    \r\n            function initDriver(supportedDrivers) {\r\n                return function () {\r\n                    var currentDriverIndex = 0;\r\n    \r\n                    function driverPromiseLoop() {\r\n                        while (currentDriverIndex < supportedDrivers.length) {\r\n                            var driverName = supportedDrivers[currentDriverIndex];\r\n                            currentDriverIndex++;\r\n    \r\n                            self._dbInfo = null;\r\n                            self._ready = null;\r\n    \r\n                            return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\r\n                        }\r\n    \r\n                        setDriverToConfig();\r\n                        var error = new Error('No available storage method found.');\r\n                        self._driverSet = Promise$1.reject(error);\r\n                        return self._driverSet;\r\n                    }\r\n    \r\n                    return driverPromiseLoop();\r\n                };\r\n            }\r\n    \r\n            // There might be a driver initialization in progress\r\n            // so wait for it to finish in order to avoid a possible\r\n            // race condition to set _dbInfo\r\n            var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\r\n                return Promise$1.resolve();\r\n            }) : Promise$1.resolve();\r\n    \r\n            this._driverSet = oldDriverSetDone.then(function () {\r\n                var driverName = supportedDrivers[0];\r\n                self._dbInfo = null;\r\n                self._ready = null;\r\n    \r\n                return self.getDriver(driverName).then(function (driver) {\r\n                    self._driver = driver._driver;\r\n                    setDriverToConfig();\r\n                    self._wrapLibraryMethodsWithReady();\r\n                    self._initDriver = initDriver(supportedDrivers);\r\n                });\r\n            })[\"catch\"](function () {\r\n                setDriverToConfig();\r\n                var error = new Error('No available storage method found.');\r\n                self._driverSet = Promise$1.reject(error);\r\n                return self._driverSet;\r\n            });\r\n    \r\n            executeTwoCallbacks(this._driverSet, callback, errorCallback);\r\n            return this._driverSet;\r\n        };\r\n    \r\n        LocalForage.prototype.supports = function supports(driverName) {\r\n            return !!DriverSupport[driverName];\r\n        };\r\n    \r\n        LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\r\n            extend(this, libraryMethodsAndProperties);\r\n        };\r\n    \r\n        LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\r\n            var supportedDrivers = [];\r\n            for (var i = 0, len = drivers.length; i < len; i++) {\r\n                var driverName = drivers[i];\r\n                if (this.supports(driverName)) {\r\n                    supportedDrivers.push(driverName);\r\n                }\r\n            }\r\n            return supportedDrivers;\r\n        };\r\n    \r\n        LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\r\n            // Add a stub for each driver API method that delays the call to the\r\n            // corresponding driver method until localForage is ready. These stubs\r\n            // will be replaced by the driver methods as soon as the driver is\r\n            // loaded, so there is no performance impact.\r\n            for (var i = 0, len = LibraryMethods.length; i < len; i++) {\r\n                callWhenReady(this, LibraryMethods[i]);\r\n            }\r\n        };\r\n    \r\n        LocalForage.prototype.createInstance = function createInstance(options) {\r\n            return new LocalForage(options);\r\n        };\r\n    \r\n        return LocalForage;\r\n    }();\r\n    \r\n    // The actual localForage object that we expose as a module or via a\r\n    // global. It's extended by pulling in one of our other libraries.\r\n    \r\n    \r\n    var localforage_js = new LocalForage();\r\n    \r\n    module.exports = localforage_js;\r\n    \r\n    },{\"3\":3}]},{},[4])(4)\r\n    });"]}